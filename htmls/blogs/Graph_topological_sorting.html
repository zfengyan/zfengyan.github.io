<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<link rel="stylesheet" href="../../assets/css/prism.css" />
		<noscript><link rel="stylesheet" href="../../assets/css/noscript.css" /></noscript>
		<!-- image grid with figure titles -->
		<style>
			.image-grid {
			  display: grid;
			  grid-template-columns: repeat(2, 1fr);
			  gap: 10px; /* Adjust the gap as needed */
			}
			.image-container {
		      text-align: center; /* Center the contents horizontally */
			}
			.image-container img {
			  width: 100%; /* Make the images fill their grid cells */
			  height: auto;
			}
			.image-title {
			  margin: 10px 0; /* Add space between the image and title */
			}
		  </style>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../blog.html" class="logo"><strong>Blog</strong> <span>Fengyan Zhang</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
							<li><a href="../../index.html">Home</a></li>
							<li><a href="../../aboutme.html">Aboutme</a></li>
							<li><a href="../../htmls/projects.html">Projects</a></li>
							<li><a href="../../htmls/experiences.html">Experiences</a></li>
							<li><a href="../../htmls/blog.html">Blog</a></li>
							<li><a href="../../htmls/fantasy.html">Fantasy</a></li>
							<li><a href="../../contact.html">Contact</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main" class="alt">
						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h3>Kahn’s Algorithm for Topological Sorting</h3>
									</header>
									<p>
										In graph theory, topological sorting, often referred to as topological ordering, is primarily 
										employed to determine the sequence of nodes in a directed acyclic graph (DAG). 
										In a DAG, vertices have interdependencies due to the existance of directed edges. 
										For instance, given two vertices U and V, a directed edge (U, V) implies that V 
										can be reached from U, while the reverse is not true - U cannot be reached from V. 
										In this context, V is regarded to have a dependency on U. 
										The topological order is essentially a linear arrangement of all the vertices within a DAG. 
										It provides a systematic depiction of feasible sequences originating from certain vertices 
										and concluding at others. <br />
										
										<br />
										Now let's delve into some fundamental yet crucial concepts regarding a DAG:
										<ol>
											<li>A DAG contains at least one vertex with the indegree zero.</li>
											<li>A DAG contains at least one vertex with the outdegree zero.</li>
										</ol>

										These two characteristics are derived from the term "acyclic" - signifying the absence of loops 
										within the DAG. Consequently, there is always at least one origin vertex and one ending vertex. 
										It's important to note that a DAG can comprise multiple disconnected components, 
										meaning that there can be separate subgraphs within the graph that are not directly connected 
										to each other. Each of these components is still a DAG, as long as they satisfy the two 
										properties mentioned above.

										<br />
										<br />

										Let us see an example:

										<br />
										<img src="../../images/blogs/Graph_top_sort.png" alt="alternatetext" style="width:600px;height:300px"><br />
										
										<br />
										Directed edges: <i>{0, 1}, {0, 2}, {1, 3}, {1, 4}, {3, 4}, {3, 5}</i>

										<br />
										"in" represents "indegree"

										<br />
										<b>Order of removal</b>: <i>0, 1, 2, 3, 4, 5</i>

										<br />
										<b>A possible topological order</b>: <i>0, 1, 2, 3, 4, 5</i>

										<br />
										Note that the sequence is not the only possible topological order. 
										For instance, <i>0, 2, 1, 3, 4, 5</i> is also a valid topological order.
										
										<br />
										The process of Kahn's algorithm:

										<div class="image-grid">
											<div class="image-container">
											  <img src="../../images/blogs/Graph_top_sort_1.png" alt="Step 1">
											  <p class="image-title">Step 1: remove node 0 (with indegree = 0) and its outward edges.
												Update the indegree of the deleted edges’ destination nodes (1 and 2).
											  </p>
											</div>
											<div class="image-container">
											  <img src="../../images/blogs/Graph_top_sort_2.png" alt="Step 2">
											  <p class="image-title">Step 2: remove node 1 and 2, alongside the outward edges. 
												Update the indegree of node 3 and 4. 
											  </p>
											</div>
											<div class="image-container">
										      <img src="../../images/blogs/Graph_top_sort_3.png" alt="Step 3">
											  <p class="image-title">Step 3: remove node 3 and its outward edges. 
												Update the indegree of node 4 and 5.
											  </p>
											</div>
											<div class="image-container">
											  <img src="../../images/blogs/Graph_top_sort_4.png" alt="Step 4">
											  <p class="image-title">Step 4: remove node 4 and 5.</p>
											</div>
										</div>


					
<pre><code class="language-cpp">
// pseudo code for an example
	
queue to store faces; // for BFS
add starting face to the queue;

while (queue is not empty)
{
	currentFace = queue.front();
	if (current face has not been processed yet) { // if not yet been processed, process it
		process it;
		mark it as processed;
	}
	queue.pop(); // pop the current face from the queue

	// Add all possible finite neighbours - not crossing constrained edges and not yet processed
	for (int i = 0; i < 3; ++i) {
		neighborFace = currentFace->neighbor(i);
		if (neighborFace is a finite face) { // only add finite neighbors
			commonEdge = common edge of (currentFace, neighborFace);
			if (commonEdge is not constrained && neighborFace has not been processed yet) {
				add the neighborFace to the queue
			}
		}
	} // end for: all neighbors (including infinite neighbors)
}
</code></pre>
										<br />
										The processed faces are shown below(highlighted in cyan)
										<br />
										<br />
										<img src="../../images/blogs/multiple_processing_tagging.PNG" alt="alternatetext" style="width:300px;height:350px"><br />
									</p>
								</div>
							</section>
					</div>


				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="copyright">
								<li>&copy; Fengyan Zhang</li><li>All rights reserved.</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/jquery.scrolly.min.js"></script>
			<script src="../../assets/js/jquery.scrollex.min.js"></script>
			<script src="../../assets/js/browser.min.js"></script>
			<script src="../../assets/js/breakpoints.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<script src="../../assets/js/main.js"></script>
			<script src="../../assets/js/prism.js"></script>

	</body>
</html>