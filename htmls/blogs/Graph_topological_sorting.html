<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<link rel="stylesheet" href="../../assets/css/prism.css" />
		<noscript><link rel="stylesheet" href="../../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../blog.html" class="logo"><strong>Blog</strong> <span>Fengyan Zhang</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
							<li><a href="../../index.html">Home</a></li>
							<li><a href="../../aboutme.html">Aboutme</a></li>
							<li><a href="../../htmls/projects.html">Projects</a></li>
							<li><a href="../../htmls/experiences.html">Experiences</a></li>
							<li><a href="../../htmls/blog.html">Blog</a></li>
							<li><a href="../../htmls/fantasy.html">Fantasy</a></li>
							<li><a href="../../contact.html">Contact</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main" class="alt">
						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h3>Kahnâ€™s Algorithm for Topological Sorting</h3>
									</header>
									<p>
										In graph theory, topological sorting, often referred to as topological ordering, is primarily 
										employed to determine the sequence of nodes in a directed acyclic graph (DAG). 
										In a DAG, vertices have interdependencies due to the existance of directed edges. 
										For instance, given two vertices U and V, a directed edge (U, V) implies that V 
										can be reached from U, while the reverse is not true - U cannot be reached from V. 
										In this context, V is regarded to have a dependency on U. 
										The topological order is essentially a linear arrangement of all the vertices within a DAG. 
										It provides a systematic depiction of feasible sequences originating from certain vertices 
										and concluding at others. <br />

										Now let's delve into some fundamental yet crucial concepts regarding a DAG:
										<ol>
											<li>A DAG contains at least one vertex with the indegree zero.</li>
											<li>A DAG contains at least one vertex with the outdegree zero.</li>
										</ol>

										These two characteristics are derived from the term "acyclic" - signifying the absence of loops 
										within the DAG. Consequently, there is always at least one origin vertex and one ending vertex. 
										It's important to note that a DAG can comprise multiple disconnected components, 
										meaning that there can be separate subgraphs within the graph that are not directly connected 
										to each other. Each of these components is still a DAG, as long as they satisfy the two 
										properties mentioned above.

										<br />
										<img src="../../images/blogs/multiple_processing_BFS.PNG" alt="alternatetext" style="width:300px;height:350px"><br />
										
<pre><code class="language-cpp">
// pseudo code for an example
	
queue to store faces; // for BFS
add starting face to the queue;

while (queue is not empty)
{
	currentFace = queue.front();
	if (current face has not been processed yet) { // if not yet been processed, process it
		process it;
		mark it as processed;
	}
	queue.pop(); // pop the current face from the queue

	// Add all possible finite neighbours - not crossing constrained edges and not yet processed
	for (int i = 0; i < 3; ++i) {
		neighborFace = currentFace->neighbor(i);
		if (neighborFace is a finite face) { // only add finite neighbors
			commonEdge = common edge of (currentFace, neighborFace);
			if (commonEdge is not constrained && neighborFace has not been processed yet) {
				add the neighborFace to the queue
			}
		}
	} // end for: all neighbors (including infinite neighbors)
}
</code></pre>
										<br />
										The processed faces are shown below(highlighted in cyan)
										<br />
										<br />
										<img src="../../images/blogs/multiple_processing_tagging.PNG" alt="alternatetext" style="width:300px;height:350px"><br />
									</p>
								</div>
							</section>
					</div>


				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="copyright">
								<li>&copy; Fengyan Zhang</li><li>All rights reserved.</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/jquery.scrolly.min.js"></script>
			<script src="../../assets/js/jquery.scrollex.min.js"></script>
			<script src="../../assets/js/browser.min.js"></script>
			<script src="../../assets/js/breakpoints.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<script src="../../assets/js/main.js"></script>
			<script src="../../assets/js/prism.js"></script>

	</body>
</html>